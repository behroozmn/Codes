# 1.Concepts

* journaling: استفاده شونده در ext4 بدین صورت که هرگاه میخواهیم چیزی در دیسک بنویسیم اول درون ژورنال میگوییم که در حال نوشتن فلان مطلب هستم. وقتی کار تمام شد در ژورنال می‌گوییم کار تمام شد. اگر وسط کار برق رفت می‌فهمیم که کدام فایل‌ها درگیر بوده و باید ریکاوری شود.
* Copy On Write یعنی هرگاه خواستیم فایلی تغییر بدهیم اول یک کپی می‌گیریم و اصلاحات را در آن انجام می‌دهیم و سپس آن قبلی را پاک میکنیم که اگر برق رفت فایل اول سالم بماند و نیاز به fsck نباشد

# 2.BlockStorage

استفاده از بلاک سایز برای ذخیره دیتا در دیسک

**مزایا**

* مناسب برای ذخیره دیتا در دیتابیس‌های معمولی

**معایب**

* هر استوریج در هر زمانی فقط به یک سرور مرتبط است

## 2.1.EXT[2-4]

```shell
mkfs.ext4 -F -O ^64bit -L '' '/dev/sdb #NewFilesystem
e2label /dev/sdb1 <Lable> #قرار دادن یک نام برای یک حافظه #lable
debugfs /dev/sdb1 #دیباگ کردن هارد دوم از دیسک دوم #Debug
```

## 2.3.NTFS

```shell
mkntfs -Q -v -F -L '' '/dev/sdb'                      #NewFilesystem
ntfslabel --force '/dev/sdb' '09191671085-BesmeAllah' #Set file system label
ntfsresize -i -f -v /dev/sdc1 #check file sysyem on /dev/sdc1 errors and (if possible) fix them
ntfsresize --force --force /dev/sdc1 #grow file system to fill the partition
ntfsresize --force --force --no-action /dev/sdc1 #دستور بالا را شبیه‌سازی میکند و درصورت وجود مشکل آن را اعلام میکند
```

## 2.4.BTRFS

<div style="direction: rtl">

* فرمت جدید از فایل‌سیستم
* قابلیت درک raid که از قابلیت COW را ساپورت می‌کند
* قابلیت ایجاد فایل خیلی بزرگ را می‌دهد
* btrfs برای دیسک‌های کوچک نظیر فلش خوب نیست و بهتر است برای دیسک‌های حجم بالا استفاده شود
* btrfs قابلیت ایجاد اسنپ‌شات دارد یعنی

</div>

```shell
mkfs.btrfs -f /dev/sdb1 /dev/sdb2 #دو پارتیشن را باهم یک فایل سیستم قرار بده
btrfs filesystem show
btrfs subvolume create <Name> #ساختن یک ساب والیوم در مسیر کنونی-یعنی یک دایرکتوری که دایرکتوری نیست و والیوم است
btrfs subvolume list <Directory> #تمام ساب‌‌والیوم‌های موجود در یک دایرکتوری را به ما نمایش می‌داد
mount -o subvolume=<nameOfSubvolume> <DeviceSuchAs /dev/sdb> <DirectoryMountPoint> # مانت کردن یک ساب‌والیوم
btrfs subvolume snapshot <From> <Directory>
```

# 3.ObjectStorage

* امکان ذخیره متادیتای کمتر نسبت به آبجکت‌استوریج
* ذخیره دیتا به‌صورت شیء(با پارامتر زیر)
    * ۱-آی‌دی: شناسه منحصربفردبرای دسترسی به فایل
    * ۲-متادیتا(متادیتای جامعی را به فایل اضافه میکند)
    * ۳-محتویات فایل(Unstructured)
* بلاک سایز ندارد
    * پِرتی سکتور ندارد
    * مناسب داده با هرنوع ساختار
* استفاده از فضای آدرس‌دهی مسطح(flat)
    * استفاده از Storage Pool
    * حذف ساختار آدرس‌دهی سلسله مراتبی(حذف ساختار فولدرهای تودرتو و مشاهده آن در FileBrowser)
        * نامناسب برای نصب سیستم عامل بر روی آن
* سیستم عامل نمی تواند با Object Store به صورت یک دیسک معمولی رفتار کند.
    * ابزارهای واسطی وجود دارند که این مشکل را حل می کنند
* Read|Write
    * سرعت Read بیشتر، بدلیل استفاده از آی‌دی (ایندکس‌شدن)
    * نوشتن دیتا و خواندن دیتا در قالب Rest API
        * استفاده از Requestهای HTTP، نظیر PUT Request(ذخیره) و Get Request(بازخوانی)
        * رفع مشکل برنامه‌نویسان هنگام ذخیره‌دیتا(ارتباط با اپلیکیشن‌ها)
    * درهنگام خواندن و نوشتن یک آبجکت به صورت کامل بارگزاری می‌شود(تغییراعمال می‌شود و مجدد ذخیره می‌گردد)
        * عدم امکان تغییر بخشی از دیتا
            * نامناسب برای لاگ فایل(Append یک خط لاگ)
        * نامناسب برای فایل‌هایی با rate تغییر زیاد(نظیر لاگ فایل،افزودن یک خط به انتها)
* ویژگی
    * مناسب برای شبکه‌های اجتماعی(وجود هر نوع دیتا و ساختار)
    * مناسب برای ذخیره اطلاعات ثابت( هرگونه تغییر در فایل ذخیره شده، سبب می‌شود تا نسخه‌ای جدید از کل فایل ایجاد و ذخیره شود)
    * مناسب برای BigData
    *

## 3.1.CEPH

<div style="direction: rtl">

* درواقع base آن بر Object storage می‌باشد.
* مقیاس‌پذیر است یعنی scalability دارد
* هر چند سیستم عامل که ceph داشته‌باشند میتوانند با هم تعامل برقرار نمایند
* پشتیبانی از مکانیزم active/active
* مکانیزم CephCluster قابلیت پشتیبانی از file و object و block دارد

</div>

## 3.2.REFS(Resilient File System)

<div style="direction: rtl">

* عدم پشتیبانی از فشرده‌سازی و رمزگذاری و پشتیبانی از فایل‌های سخت‌افزاری(پایه درایور)
* استفاده از ساختار متادیتا تحت عنوان BPlusTree[b+Tree] برای بهینه‌سازی جستجو و دسترسی به دیتاIntegrityStrem که شناسایی و اصلاح خطا با checksum برای هر بلوک داده را انجام می‌دهد
* مدیریت حجم بزرگ تا ۳۵ پتابایت
* پشتیبانی از فرمت دیسک‌های مجازی Virtual Hard Disk (هایپروی)
* کلون و اسنپشات

</div>

# 4.TMPFS

در لینوکس، tmpfs توسط هسته (Linux kernel) پشتیبانی می‌شود و یکی از انواع فایل‌سیستم‌های داخلی است که مستقل از دیسک عمل می‌کند.

![ObjectStorage-vs-Block-Storage-Services.jpg](_srcFiles/Images/ObjectStorage-vs-Block-Storage-Services.jpg "ObjectStorage-vs-Block-Storage-Services.jpg")





















عالی! سوال خیلی خوب و مهمی پرسیدی. بیای درک دقیق‌تری از تفاوت مفاهیم زیر داشته باشیم:

---

## 📌 ۱. **In-memory Filesystem**  
### معنی: فایل‌سیستم مبتنی بر حافظه (RAM)

### توضیح:
- داده‌ها در **حافظه RAM** ذخیره می‌شوند.
- بسیار سریع است، چون به جای دیسک از حافظه استفاده می‌کند.
- داده‌ها **غیردائمی** هستند؛ با ری‌استارت سیستم یا خاموشی از بین می‌روند.

### مثال:
- `tmpfs` (در لینوکس)
- `ramfs` (در لینوکس)
- `tmpfs` در BSD
- `RAM Disk` در ویندوز

---

## 📌 ۲. **Virtual Filesystem**  
### معنی: فایل‌سیستم مجازی

### توضیح:
- یک لایه نرم‌افزاری که **به کاربر و برنامه‌ها شبیه یک فایل‌سیستم عملی می‌کند** ولی لزوماً داده‌ها را روی دیسک ذخیره نمی‌کند.
- ممکن است داده‌ها در حافظه، در فایل، یا حتی از طریق شبکه مدیریت شوند.
- اغلب برای **抽象** (abstract) کردن منابع مختلف داده به عنوان یک سیستم فایل ظاهری استفاده می‌شود.

### مثال:
- `tmpfs` (هم In-memory هم Virtual است)
- `/proc`, `/sys` (در لینوکس — فقط داده‌های سیستم را نشان می‌دهند)
- `FUSE` (Filesystem in Userspace)
- `SSHFS` (فایل‌سیستم مجازی از راه دور)
- `overlayfs` (برای محیط‌های container مثل Docker)

---

## 📌 ۳. **Temporary Filesystem**  
### معنی: فایل‌سیستم موقت

### توضیح:
- هر فایل‌سیستمی که **داده‌های آن غیردائمی** هستند، جزو این دسته قرار می‌گیرند.
- ممکن است **In-memory** باشد یا **فایل‌های موقت روی دیسک**، ولی مهم این است که داده‌ها **پاک می‌شوند**.

### مثال:
- `tmpfs`
- `ramfs`
- `/tmp` در سیستم‌های لینوکس (معمولاً tmpfs mount شده)
- `mktemp` (فایل موقت در زمان اجرا)
- Temporary Tables در پایگاه داده

---

## 🧠 رابطه و تفاوت این سه مفهوم:

| مفهوم | نوع | توضیح |
|--------|------|-------|
| **In-memory FS** | زیرمجموعه | فایل‌سیستمی که **داده‌ها را در RAM ذخیره می‌کند** |
| **Virtual FS**   | ابرمجموعه | تمام فایل‌سیستم‌هایی که **ظاهری از فایل‌ها و پوشه‌ها ارائه می‌دهند بدون اینکه داده‌ها لزوماً روی دیسک باشند** |
| **Temporary FS** | زیرمجموعه | فایل‌سیستمی که **داده‌ها فقط موقتاً وجود دارند** |

### 🔁 پوشش متقابل:
- `tmpfs` ✅ In-memory ✅ Virtual ✅ Temporary
- `/proc` ✅ Virtual ❌ In-memory ❌ Temporary (در زمان اجرا وجود دارد)
- `ramfs` ✅ In-memory ❌ Virtual ✅ Temporary
- `SSHFS` ✅ Virtual ❌ In-memory ❌ Temporary

---

## 📊 جدول مقایسه نهایی:

| مفهوم | داده در RAM | داده دائمی؟ | نوع | مثال |
|--------|--------------|-------------|------|-------|
| **In-memory FS** | ✔️ | ❌ | زیرمجموعه Virtual FS | `tmpfs`, `ramfs` |
| **Virtual FS**   | گاهی | گاهی | ابرمجموعه | `tmpfs`, `/proc`, `FUSE`, `SSHFS` |
| **Temporary FS** | گاهی | ❌ | زیرمجموعه | `tmpfs`, `ramfs`, `/tmp` |

---

## 💬 خلاصه:

> - **In-memory Filesystem**: داده‌ها در RAM هستند (سریع).
> - **Virtual Filesystem**: یک مفهوم گسترده‌تر که شامل انواع فایل‌سیستم‌های مجازی است.
> - **Temporary Filesystem**: داده‌ها فقط موقت هستند (با خاموشی یا ری‌استارت از بین می‌روند).

---

اگر دوست داشتی بدونی:
- نحوه تنظیم `tmpfs` در لینوکس
- تفاوت `tmpfs` با `ramdisk`
- بهترین کاربردهای هر کدام در محیط‌های توسعه و سرور

فقط بفرمایید 😊










